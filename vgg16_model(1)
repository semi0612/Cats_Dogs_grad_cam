```
from tensorflow.keras import layers
from tensorflow.keras.layers import InputLayer

model = tf.keras.Sequential()
model.add(InputLayer(input_shape=(80, 80, 3)))
model.add(Conv2D(64, (3, 3), activation='relu', padding='same', name = 'block1_conv1'))
model.add(Conv2D(64, (3, 3), activation='relu', padding='same', name =  'block1_conv2'))
model.add(MaxPooling2D((2, 2), strides = (2,2), name = 'block1_pool'))

  # Block 2
model.add(Conv2D(128, (3, 3), activation='relu', padding='same', name = 'block2_conv1'))
model.add(Conv2D(128, (3, 3), activation='relu', padding='same', name = 'block2_conv2'))
model.add(MaxPooling2D((2, 2), strides = (2,2), name = 'block2_pool'))

  # Block 3
model.add(Conv2D(256, (3, 3), activation='relu', padding='same', name = 'block3_conv1'))
model.add(Conv2D(256, (3, 3), activation='relu', padding='same', name = 'block3_conv2'))
model.add(Conv2D(256, (3, 3), activation='relu', padding='same', name = 'block3_conv3'))
model.add(MaxPooling2D((2, 2), strides = (2,2), name = 'block3_pool'))

  # Block 4
model.add(Conv2D(512, (3, 3), activation='relu', padding='same', name = 'block4_conv1'))
model.add(Conv2D(512, (3, 3), activation='relu', padding='same', name = 'block4_conv2'))
model.add(Conv2D(512, (3, 3), activation='relu', padding='same', name = 'block4_conv3'))
model.add(MaxPooling2D((2, 2), strides = (2,2), name = 'block4_pool'))

  # Block 5
model.add(Conv2D(512, (3, 3), activation='relu', padding='same', name = 'block5_conv1'))
model.add(Conv2D(512, (3, 3), activation='relu', padding='same', name = 'block5_conv2'))
model.add(Conv2D(512, (3, 3), activation='relu', padding='same', name = 'block5_conv3'))
model.add(MaxPooling2D((2, 2), strides=(2,2), name = 'block5_pool'))

  # Dense
model.add(Flatten())
  #x = Dense(4096,activation='relu')(x)
  #x = Dropout(0.5) (x)
  #x = Dense(1024,activation='relu')(x)
  #x = Dropout(0.5) (x)
model.add(Dense(256, activation='relu'))
model.add(Dense(1, activation='sigmoid'))

#RMSprop = tf.optimizers.RMSprop(lr=1e-4)
#model.compile(loss='binary_crossentropy',
#              optimizer=RMSprop,
#              metrics=['acc'])

model.summary()
```

'''
IMG_HEIGHT = 244
IMG_WIDTH = 224

input_tensor = Input(shape=(IMG_HEIGHT, IMG_WIDTH, 3), name='input')
def vgg16_model(input_data):
  x = Conv2D(64, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(input_data)
  x = Conv2D(64, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(x)
  x = BatchNormalization()(x)
  x = MaxPooling2D((2,2))(x)
 
  x = Conv2D(128, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(x)
  x = Conv2D(128, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(x)
  x = BatchNormalization()(x)
  x = MaxPooling2D((2,2))(x)

  x = Conv2D(256, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(x)
  x = Conv2D(256, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(x)
  x = Conv2D(256, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(x)
  x = BatchNormalization()(x)
  x = MaxPooling2D((2,2))(x)

  x = Conv2D(512, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(x)
  x = Conv2D(512, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(x)
  x = Conv2D(512, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(x)
  x = BatchNormalization()(x)
  x = MaxPooling2D((2,2))(x)

  x = Conv2D(512, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(x)
  x = Conv2D(512, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(x)
  x = Conv2D(512, (3, 3), activation='relu', padding='same', kernel_initializer='he_normal')(x)
  x = BatchNormalization()(x)
  x = MaxPooling2D((2,2))(x)

  x = Flatten()(x)
  x = Dense(256, activation='relu')(x)
  x = BatchNormalization()(x)
  x = Dense(1, activation='sigmoid')(x)

  return Model(input_data, x)
  
vgg16 = vgg16_model(input_tensor)

optimizer = optimizers.SGD(lr=0.001, momentum=0.9)
vgg16.compile(optimizer=optimizer,
              loss='binary_crossentropy',
              metrics=['accuracy'])
              
vgg16.summary()
'''
  #return model_vgg16
